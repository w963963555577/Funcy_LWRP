#pragma kernel CSMain

//Matrix4x4 v = Camera.main.worldToCameraMatrix;
//Matrix4x4 p = Camera.main.projectionMatrix; //unity C# use opengl standard projection matrix
//cullingComputeShader.SetMatrix("_VPMatrix", p * v); //set from C#
float4x4 _VMatrix;
float4x4 _PMatrix;

StructuredBuffer<float3x2> _BoundsBuffer; //will not change until instance count change
AppendStructuredBuffer<uint> _VisibleInstanceOnlyTransformIDBuffer; //will set counter to 0 per frame, then fill in by this compute shader

float3 WorldToViewPoint(float4x4 VPMatrix, half3 worloPos)
{
    half4 result = mul(VPMatrix, float4(worloPos, 1.0));
    result.xyz /= result.w;
    return result.xyz;
}

[numthreads(1024, 1, 1)]
void CSMain(uint3 id: SV_DispatchThreadID)
{
    float4x4 _VPMatrix = mul(_PMatrix, _VMatrix);
    float3 _center = _BoundsBuffer[id.x]._m00_m10_m20;
    float3 _extents = _BoundsBuffer[id.x]._m01_m11_m21;
    
    float3 p0 = _center;
    float3 p1 = _center + float3(+_extents.x, +_extents.y, +_extents.z);
    float3 p2 = _center + float3(-_extents.x, -_extents.y, -_extents.z);
    float3 p3 = _center + float3(+_extents.x, -_extents.y, +_extents.z);
    float3 p4 = _center + float3(-_extents.x, +_extents.y, -_extents.z);
    float3 p5 = _center + float3(+_extents.x, +_extents.y, -_extents.z);
    float3 p6 = _center + float3(-_extents.x, -_extents.y, +_extents.z);
    float3 p7 = _center + float3(-_extents.x, +_extents.y, +_extents.z);
    float3 p8 = _center + float3(+_extents.x, -_extents.y, -_extents.z);
    
    p0 = abs(WorldToViewPoint(_VPMatrix, p0));
    p1 = abs(WorldToViewPoint(_VPMatrix, p1));
    p2 = abs(WorldToViewPoint(_VPMatrix, p2));
    p3 = abs(WorldToViewPoint(_VPMatrix, p3));
    p4 = abs(WorldToViewPoint(_VPMatrix, p4));
    p5 = abs(WorldToViewPoint(_VPMatrix, p5));
    p6 = abs(WorldToViewPoint(_VPMatrix, p6));
    p7 = abs(WorldToViewPoint(_VPMatrix, p7));
    p8 = abs(WorldToViewPoint(_VPMatrix, p8));
    
    half minX = min(min(min(p1.x, p2.x), min(p3.x, p4.x)), min(min(p5.x, p6.x), min(p7.x, p8.x)));
    half minY = min(min(min(p1.y, p2.y), min(p3.y, p4.y)), min(min(p5.y, p6.y), min(p7.y, p8.y)));
    
    half2 allow = half2(1.0, 1.0);
    if (p0.z <= 1.0 && minX <= allow.x && minY <= allow.y)
    {
        _VisibleInstanceOnlyTransformIDBuffer.Append(id.x);
    }
}
